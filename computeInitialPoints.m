function [r0,Info] = computeInitialPoints(BW,options,varargin)
% COMPUTEINITIALPOINTS  Generate a set of initial particle locations for
% modeling.
%
% r0 = computeInitialPoints(BW,options)
% [r0,Info] = computeInitialPoints(BW,options,'r0set',r0set,'problem_scales',problem_scales)
%
% Input parameters:
% BW : A binary mask of a single object
% options : an instance of class seedPointOptions
%
% Optional input parameters (parameter/value paris):
% r0 : a set of possible initial points. This parameter is required if
%   options.Point_Selection_Method is either 'r0set_random' or
%   'r0set_uniformRandom'.
% problem_scales : the problem scales structure generated by
%   computeProblemScales. This should be given if
%   options.Wigner_Seitz_Radius_Space is not 'grid'.
%
% Output parameters:
% r0 : Cell array of length options.Iterations where each element is an
%   NxD array of initial positions (D is the dimension of the data, N is
%   the number of points returned).
% Info : A structure array giving information that may be off help when
%        debuging. This is only output when options.Debug is true. The
%        fields of Info are
%           N : the number of particles returned (number of rows in r0).
%
%           givenMethodFailed : boolean. If true, then method requested
%           failed to produce a single particle position. (See notes below
%           for more information about this.)
%
%           r0setHexData (If in 2D) : A structure with fields X, Y, Z with
%           the data returned from using decimateData on r0set. This field
%           is only returned if the method is 'uniformRandom' or
%           'r0set_uniformRandom'.
%
%           r0setLatticeEdges (If in N-D) : A cell array with the edges
%           used for the hyper-cubic lattice. This field is only returned
%           if the method is 'uniformRandom' or 'r0set_uniformRandom'.
%
% Description of Point Selection Methods:
% 'random' : Select N random locations from the binary mask where N is the
%   area of the mask divided by the effective (hyper-)volume of a particle
%   (pi*rs^2 in 2D).
%
% 'uniform' : A lattice is overlaid on the binary mask, and the centers of
%   each lattice cell that are inside the binary mask are used as the
%   initial points.
%
% 'uniformRandom' : A lattice is overlaid on the binary mask, and from
%   each lattice cell a random point from the mask is used as an initial
%   point.
%
% 'r0set_random' : From a set of possible initial positions, N random
%   points are chosen, where N is the area of the mask divided by the
%   effective volume of a particle (pi*rs^2 in 2D).
%
% 'r0set_uniformRandom' : A lattice is overlaid on the binary mask, and
%   from each lattice cell a random point from a set of possible initial
%   positions is chosen.
%
% If a lattice is used, the lattice is a hexagonal lattice in 2-D, and is a
% (hyper-)cubic lattice in N-D. The lattice constant is chosen so that the
% volume of each lattice cell is equal to the effective volume of a
% (hyper-)spherical particle with a radius given by the Wigner-Seitz
% radius.
%
% Notes:
%
% * This function is run for a single object, not an image with many
% objects.
%
% * If the methods 'uniform', 'r0set_random', or
% 'r0set_uniformRandom' fail to produce a single particle location, then
% the 'random' method will be used.
%
% * If the binary mask area is smaller than the effective particle area,
% then one point will still be output.
%
% * All initial points returned will be located inside of the binary mask.
%
% See also DECIMATEDATA COMPUTEBOUNDARYINFORMATION

% James Kapaldo

[sz, lattice_constant, N, r0set, BWpts, offset, problem_scales, use_cellarray] = parse_inputs(BW, options, varargin{:});
R = options.Iterations;
debug = options.Debug;
Info = [];

switch options.Point_Selection_Method
    case 'random'
        r0 = r0set_random(BWpts, N, R);

    case 'uniform'
        if debug
            [r0, Info] = uniform(BW, lattice_constant, R);
        else
            r0 = uniform(BW, lattice_constant, R);
        end

    case 'r0set_random'
        r0 = r0set_random(r0set, N, R);

    case 'uniformRandom'
        if debug
            [r0, Info] = r0set_uniformRandom(BWpts, sz, lattice_constant, R, offset);
        else
            r0 = r0set_uniformRandom(BWpts, sz, lattice_constant, R, offset);
        end

    case 'r0set_uniformRandom'
        if debug
            [r0, Info] = r0set_uniformRandom(r0set, sz, lattice_constant, R, offset);
        else
            r0 = r0set_uniformRandom(r0set, sz, lattice_constant, R, offset);
        end

    otherwise
        error('computeInitialPoints:unknownMethod','Unknown method. Allowed methods are ''random'', ''uniform'', ''uniformRandom'',''r0set_random'', ''r0set_uniformRandom''.')
end

if debug
    Info.givenMethodFailed = false(1,R);
end

% Find any repetition with zero initial points and use random method.
for i = R:-1:1
    if isempty(r0{i})
        r0_i = r0set_random(BWpts, N, 1);
        r0{i} = r0_i{1};
        if debug
            Info.givenMethodFailed(i) = true;
        end
    end
    if debug
        Info.N(i) = size(r0{i},1);
    end
end

% Convert initial positions to solver space
gts = problem_scales.grid_to_solver;
r0 = cellfun(@(x) x .* gts, r0, 'UniformOutput',false);

if R == 1 && ~use_cellarray
    r0 = r0{1};
end


end

function [sz, lattice_constant, N, r0set, BWpts, offset, problem_scales, use_cellarray] = parse_inputs(BW, options, varargin)

    sz = size(BW);
    D = numel(sz);

    % Validate options -- cannot check if it is type seedPointOptions
    % because it is copied to a struct when run in parallel.
    % validateattributes(options, {'seedPointOptions'}, {})

    % Parse remaining inputs
    p = inputParser;
    p.FunctionName = 'computeInitialPoints';

    validateProblemScales = @(stct) isfield(stct,'grid_spacing') && ...
                                    isfield(stct,'grid_to_solver') && ...
                                    (numel(stct.grid_spacing) == D) && ...
                                    (numel(stct.grid_to_solver) == D);

    addParameter(p,'problem_scales', ...
        struct('grid_spacing',ones(1,D), 'grid_to_solver',ones(1,D)), ...
        validateProblemScales)
    addParameter(p,'r0set',[], @(t) validateattributes(t, {'double'}, {'2d'}))
    addParameter(p,'use_cellarray',true, @(t) t==0 || t==1)

    parse(p,varargin{:})
    r0set = p.Results.r0set;
    problem_scales = p.Results.problem_scales;
    use_cellarray = p.Results.use_cellarray;

    % Get the wigner-seitz radius in grid space
    if ~strcmp(options.Wigner_Seitz_Radius_Space, 'grid')
        rs = getGridWignerSeitz(problem_scales, options);
    else
        rs = options.Wigner_Seitz_Radius;
    end

    % Check wigner-seitz dimensions. Each of the functions for getting the
    % random points allows a different wigner-seitz radius for each
    % dimension. However, outside of this function, this functionality has
    % not been coded.
    if (numel(rs) == 1) && (D ~= 1)
        rs = rs*ones(1,D);
    end
    if numel(rs) ~= D
        error('computeInitialPoints:DimensionMismatch', 'The dimension of the Wigner-Seitz radius does not equal the dimension of the data.')
    end

    % Get the expected number of particles. Note that the volume of an
    % n-ellipsiod is
    %
    % $$V = \frac{\pi^{n/2}}{\Gamma(n/2+1)}\prod_k c_k$$
    %
    % where c_k are the axis lengths along each dimension.
    particle_size = pi^(D/2)/gamma(D/2+1)*prod(rs);
    N = max(round( sum(BW(:)) / particle_size ), 1);

    % Get the lattice constant. In 2D I use a hexagonal lattice, in ND I
    % use a hyper-cubic lattice. Note the Wigner-Seitz radius is the
    % "radius" of the lattice cell.
    if D == 2
        cell_size = 3*sqrt(3)/2 * rs(1)^2;
    else
        cell_size = prod(2*rs);
    end
    lattice_constant = 2 * rs * (particle_size/cell_size)^(1/D);

    % Several methods use the points of the mask and the (offset) center of
    % the mask.
    [BWpts{1:D}] = ind2sub(sz,find(BW));
    BWpts = cat(2,BWpts{:});
    offset = mean(BWpts,1) - rs/2;

    if isempty(r0set) && strncmp('r0set',options.Point_Selection_Method,4)
        error('computeInitialPoints:incompatableParameters', ...
            ['No initial set of points was given, but the point selection',...
            ' method requires a set of initial points.'])
    end
end


% function r0_set = random(BW, N, repetitions)
%
%     sz = size(BW);
%     D = numel(sz); % number of dimensions
%
%     idx = find(BW);
%     r0set = cell(1,D);
%     [r0set{:}] = ind2sub(sz,idx);
%     r0set = cat(2,r0set{:});
%
%     r0_set = r0set_random(r0set, N, repetitions);
% end

function [r0_set, varargout] = uniform(BW, lattice_constant, repetitions)

    debug = nargout > 1;

    % Get size and dimension of input mask
    sz = size(BW);
    D = numel(sz);

    % Create gridded interpolant for data
    BW = griddedInterpolant(BW);

    if D == 2
        % If 2D, then use the centers of a hexagonal grid.
        % Create hexagonal grid.
        a = lattice_constant(1); % Use the first value for the size of the hexagons
        x = a/2 : a : sz(2)+a;
        y = a/2 : sqrt(3)*a/2 : sz(1)+a;
        [X,Y] = ndgrid(x,y);
        X(:,2:2:end) = X(:,2:2:end) + a/2;

        % Create start points.
        r0set = {Y(:),X(:)};
    else
        % If ND, then use the centers of a (hyper-)cubic lattice.
        % Create center points.
        for i = D:-1:1
            r0set{i} = (1 : lattice_constant(i) : (sz(i)-lattice_constant(i))) ...
                + lattice_constant(i)/2;
        end

        % Create start points
        [r0set{:}] = ndgrid(r0set{:});
        r0set = cellfun(@(x) x(:), r0set,'UniformOutput',false);
    end

    if debug
        Info = [];
    end

    % Create `repetitions` sets of initial points, each with small random
    % offsets
    r0set = cat(2,r0set{:});
    for i = repetitions:-1:1
        offset = lattice_constant.*(rand(1,D)-0.5);
        r0set_i = r0set + offset;

        % Make sure all points are in the valid region.
        remove = BW(r0set_i) == 0;
        r0set_i(remove,:) = [];

        r0_set{i} = r0set_i;

        if debug
            Info.offset{i} = offset;
        end
    end

    if debug
        varargout{1} = Info;
    end
end

% function [r0_set, varargout] = uniformRandom(BW, lattice_constant, repetitions)
%     sz = size(BW);
%
%     idx = find(BW);
%     r0set = cell(1,D);
%     [r0set{:}] = ind2sub(sz,idx);
%     r0set = cat(2,r0set{:});
%
%     offset = mean(r0set,1) - lattice_constant/2;
%
%     if nargout > 1
%         [r0_set, Info] = r0set_uniformRandom(r0set, sz, lattice_constant, repetitions, offset);
%         varargout{1} = Info;
%     else
%         r0_set = r0set_uniformRandom(r0set, sz, lattice_constant, repetitions, offset);
%     end
% end

function r0_set = r0set_random(r0set, N, repetitions)
    r0set = unique(r0set,'rows');
    r0_num = size(r0set,1);
    if r0_num < N
        warning('r0set_random:N_to_large',['The number of possible ', ...
            'starting locations is smaller than the requested number of ', ...
            'points. Using all possible starting locations.'])

        r0_set = repmat({r0set}, 1, repetitions);
    else
        for i = repetitions:-1:1
            r0_set{i} = r0set(randperm(r0_num,N),:);
        end
    end
end

function [r0_set, varargout] = r0set_uniformRandom(r0set, sz, lattice_constant, repetitions, offset)
    % Get the number of posibile initial points and the dimension of the
    % problem.
    [N,D] = size(r0set);
    debug = nargout > 1;

    if D == 2
        % If the problem is 2-D, then use a hexagonal lattice.

        % Initialize the offset, if not give.
        if nargin < 3
            offset = zeros(1,D);
        end
        % Initialize the Info output.
        if debug
            Info = [];
        end

        % Offset the initial points (can be usefull with the hexagonal discretization.)
        r0set = r0set - offset;

        for i = repetitions:-1:1
            try
                % Group the initial points into hexagons and choose one point
                % from each hexagon.
                dcmt = decimateData(r0set(:,1),r0set(:,2),1:size(r0set,1),...
                    'reductionMethod',@(x) x(randi(numel(x),1)),...
                    'gridType','hexagonal',...
                    'binSize',lattice_constant(1),...
                    'cleanHexagonData',1);

                r0_set{i} = r0set(dcmt.Z,:) + offset;
                if debug
                    dcmt.X = dcmt.X + mu(1);
                    dcmt.Y = dcmt.Y + mu(2);
                    Info.r0setHexData(i) = dcmt;
                end
            catch ME
                if strcmp(ME.identifier,'MATLAB:discretize:EmptyOrScalarEdges')
                    r0_set{i} = [];
                else
                    rethrow(ME)
                end
            end
        end
    else
        % If the problem is not 2-D, then use a (hyper-)cubic lattice.
        bin = zeros(N,D,get_minimum_uint_class(sz));

        % Bin the data.
        for i = D:-1:1
            edges{i} = 0 : lattice_constant(i) : (sz(i)+lattice_constant(i));
            bin(:,i) = discretize(r0set{i},edges);
        end

        if debug
            Info.r0setLatticeEdges = edges;
        end

        indices = (1:N)'; % array of point indices
        valid = all(bin>0,2); % logical array saying if point is fully inside lattice.

        % only use valid points.
        indices = indices(valid);
        bin = bin(valid,:);

        % group all poins within each lattice cell.
        point_indices = accumarray(bin, indices, [], @(x) {x}, {});
        point_indices = point_indices(~cellfun(@isempty, point_indices)); % remove cells without any points.

        % From each lattice cell, select one random point. Do this `repetitions` times.
        for i = repetitions:-1:1
            r0_set_idx = cellfun(@(x) x(randi(numel(x),1)), point_indices);
            r0_set{i} = r0set(r0_set_idx,:);
        end
    end

    if debug
        varargout{1} = Info;
    end
end
